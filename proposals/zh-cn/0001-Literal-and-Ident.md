# 标识符，编码与常量

## 标识符

DustLang中的标识符有如下要求：

1. 标识符中不能含有ASCII符号。
2. 标识符第一位不能是ASCII数字。
3. 标识符第一位可以是下划线`_`。
4. 标识符中可以包含下划线`_`。
5. 标识符中不可以含有Unicode的空白字符。
6. 除以上限制，标识符可以使用任何Unicode字符。

## 编码

DustLang的文件采用UTF-8格式编码，这也就意味着字面量也是被编译为UTF-8格式。

## 字面量

字面量是在源代码中直接写入的值。这些值除了数字之外，其他的均会被编译到全局静态变量区。

> 即便是数字，也有可能被写入全局静态变量区。这个取决于不同平台的实现。

DustLang支持编译器库接口来扩展多种形式的字面量。

> 注： 编译器库接口至少需要在bootstrap 1以上的级别才可用。

### 数字字面量

数字字面量是第一个字符以ASCII数字开始的。如果第一位是`1-9`则就是普通十进制格式的数字；如果第一位是`0`，则几种可能性：

- 第二位是小数点`.`，则是一个浮点数。
- 第二位如果是`x`，则是一个十六进制整数。
- 第二位开始是一个标识符，则由编译器库接口注入的代码逻辑决定。

数字字面量可以出现`_`分割，不影响整数的语义。

> Bootstrap 0不支持分隔符。

#### 整数

除了整数进制相关的字符，不允许出现其他的字符。

- 十进制： 只允许出现 `0-9_`。
- 十六进制：只允许出现`0-9A-Fa-f_`。

#### 浮点数

> 某些后端不支持浮点数类型，编译将会报错。

浮点数有两种形式，分别是小数形式与科学计数法。

- 小数形式只允许出现`0-9\._`
- 科学计数法形式只允许出现`0-9\._Ee`

### 字符串字面量

字符串字面量是以一个以标识符开头，跟着一个双引号；或者就直接是一个双引号。

#### UTF-8字符串

UTF-8字符串直接以双引号开始：

```
"这是一个UTF-8字符串"
"Emoji 😀"
```

#### 字节字符串

字节字符串以`b`标识符或者以`x`标识。

- ASCII字节字符串以`b`标识符开头。双引号中只允许出现ASCII字符串。
- 十六进制字符串以`x`标识符开头，双引号中只允许出现`0-9a-zA-Z`
- 除了这两个标识以外，可以通过编译器库接口扩展注入新的标识符。

### 字符字面量

字符字面量是以标识符开头，跟着单引号；或者直接由一个单引号组成。单引号中是一个UTF-8字符

```
'a'
'好'
```

> 类似的，字符字面量也支持通过在引号前放标识符扩展。

## Pest语法

```pest
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }

// ident
ident_first = _{ LETTER | "_" }
ident_inner = _{ ident_first | NUMBER }
ident       =  { ident_first ~ ident_inner* }

// number
num_literal_inner = _{ LETTER | NUMBER | "." | "_" }
num_literal  =  { NUMBER ~ num_literal_inner*}

// string
literal_inner_char = _{ !"\"" ~ ("\\\"" | ANY) }
literal_inner      =  { literal_inner_char* }
string_literal = { ident? ~ "\"" ~ literal_inner ~ "\"" }

// char
char_literal = { "'" ~ LETTER? ~ "'" }

literal = { string_literal | num_literal }
```

## 编译器内部接口

整数字面量接口：

```
@cii::literal::int
```

字符串字面量接口：

```
@cii::literal::str
```

字符字面量接口：

```
@cii::literal::char
```

被这些接口修饰的函数将会在编译期被调用。
